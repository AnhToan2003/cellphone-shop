import dayjs from "dayjs";
import { z } from "zod";

import { Order } from "../models/Order.js";
import { Product } from "../models/Product.js";
import { Review } from "../models/Review.js";

import {
  loadActivePromotions,
  resolveEffectivePricing,
} from "../utils/pricing.js";
import {
  adjustUserLifetimeSpend,
  restockOrderInventory,
} from "../services/order.service.js";
import {
  buildTransferContent,
  buildVietqrImageUrl,
  generateVietqrReference,
} from "../services/vietqr.service.js";

const orderSchema = z.object({
  items: z
    .array(
      z.object({
        productId: z.string().min(1, "Product is required"),
        quantity: z.number().int().min(1, "Quantity must be at least 1"),
        color: z.string().optional().default(""),
        capacity: z.string().optional().default(""),
      })
    )
    .min(1, "Cart is empty"),
  shippingInfo: z.object({
    fullName: z.string().min(2, "Full name must contain at least 2 characters"),
    phone: z.string().min(8, "Phone number is not valid"),
    address: z.string().min(5, "Address must contain at least 5 characters"),
  }),
  paymentMethod: z.enum(["cod", "vietqr"]).default("cod"),
  summary: z
    .object({
      shipping: z
        .number()
        .min(0)
        .max(1_000_000)
        .optional(),
      items: z.number().min(0).optional(),
      grand: z.number().min(0).optional(),
    })
    .optional(),
});

const asyncHandler = (fn) => (req, res, next) =>
  Promise.resolve(fn(req, res, next)).catch(next);

const updateStatusSchema = z.object({
  status: z.enum(["pending", "processing", "shipped", "delivered", "cancelled"]),
});

const ORDER_STATUS_LABELS = {
  pending: "Chờ xác nhận",
  processing: "Đã duyệt",
  shipped: "Đang giao",
  delivered: "Đã giao",
  cancelled: "Đã hủy",
};

const SHIPPING_FLAT_FEE = 30_000;

const DEFAULT_WARRANTY_MONTHS = 12;
const FALLBACK_WARRANTY_POLICY =
  Product?.schema?.paths?.warrantyPolicy?.options?.default ||
  "Lỗi 1 đổi 1 trong 10 ngày. Bảo hành 12 tháng. Không bảo hành khi rơi vở hoặc vô nước.";

const resolveWarrantyMonths = (product) => {
  if (!product) {
    return DEFAULT_WARRANTY_MONTHS;
  }

  const rawValue =
    typeof product.warrantyMonths === "number"
      ? product.warrantyMonths
      : Number(product.warrantyMonths);

  if (Number.isFinite(rawValue) && rawValue > 0) {
    return Math.max(1, Math.min(rawValue, 60));
  }

  return DEFAULT_WARRANTY_MONTHS;
};

const getItemProductId = (item = {}) => {
  const productRef = item.product ?? item;
  if (!productRef) return null;

  if (typeof productRef === "string") {
    return productRef;
  }

  if (typeof productRef === "object") {
    if (productRef._id) {
      return productRef._id.toString();
    }
    if (productRef.id) {
      return productRef.id.toString();
    }
    if (
      typeof productRef.toString === "function" &&
      productRef.toString !== Object.prototype.toString
    ) {
      const value = productRef.toString();
      if (value && value !== "[object Object]") {
        return value;
      }
    }
  }

  return null;
};

const buildReviewKey = (orderId, productId) => {
  if (!orderId || !productId) {
    return null;
  }
  return `${orderId}:${productId}`;
};
const buildOrderPayload = (order, reviewedProducts) => {
  const doc =
    typeof order.toObject === "function"
      ? order.toObject({ virtuals: true })
      : { ...order };

  let reviewedSet = null;
  if (reviewedProducts) {
    if (reviewedProducts instanceof Set) {
      reviewedSet = new Set(
        Array.from(reviewedProducts, (value) => value.toString())
      );
    } else if (Array.isArray(reviewedProducts)) {
      reviewedSet = new Set(
        reviewedProducts.map((value) => value.toString())
      );
    } else {
      reviewedSet = new Set([reviewedProducts.toString()]);
    }
  }

  if (Array.isArray(doc.items)) {
    const orderId =
      doc._id && typeof doc._id.toString === "function"
        ? doc._id.toString()
        : order?._id?.toString?.() || "";
    doc.items = doc.items.map((item) => {
      const current =
        typeof item?.toObject === "function"
          ? item.toObject({ virtuals: true })
          : { ...item };
      const productId = getItemProductId(current);
      const reviewKey = buildReviewKey(orderId, productId);
      return {
        ...current,
        alreadyReviewed: reviewedSet
          ? (reviewKey && reviewedSet.has(reviewKey)) ||
            (productId && reviewedSet.has(productId)) ||
            Boolean(current.alreadyReviewed)
          : Boolean(current.alreadyReviewed),
      };
    });
  }

  return {
    ...doc,
    statusLabel: ORDER_STATUS_LABELS[doc.status] || doc.status,
  };
};

const populateOrder = (query) =>
  query
    .populate("user", "name email customerTier lifetimeSpend")
    .populate(
      "items.product",
      "name slug images finalPrice price oldPrice warrantyPolicy warrantyMonths brand"
    );

export const createOrder = asyncHandler(async (req, res) => {
  const payload = orderSchema.parse(req.body);

  const productIds = payload.items.map((item) => item.productId);
  const products = await Product.find({ _id: { $in: productIds } });
  const productMap = new Map(
    products.map((product) => [product._id.toString(), product])
  );

  if (productMap.size !== productIds.length) {
    return res.status(400).json({
      success: false,
      message: "One or more products do not exist",
    });
  }

  let itemsTotal = 0;
  const orderItems = [];
  const promotions = await loadActivePromotions();
  const customerTier = req.user?.customerTier;

  for (const item of payload.items) {
    const product = productMap.get(item.productId);
    if (!product) {
      return res.status(400).json({
        success: false,
        message: "Product not found",
      });
    }

    if (product.stock < item.quantity) {
      return res.status(400).json({
        success: false,
        message: `Product ${product.name} is out of stock`,
      });
    }

    const pricing = resolveEffectivePricing(product, {
      promotions,
      customerTier,
    });
    const price = pricing.finalPrice;
    const rawListedPrice =
      typeof product.oldPrice === "number" ? product.oldPrice : Number(product.oldPrice);
    const listedPrice =
      Number.isFinite(rawListedPrice) && rawListedPrice > 0
        ? rawListedPrice
        : price;
    const lineTotal = price * item.quantity;
    itemsTotal += lineTotal;

    product.stock = Math.max(product.stock - item.quantity, 0);
    await product.save();

    orderItems.push({
      product: product._id,
      name: product.name,
      price,
      listedPrice,
      quantity: item.quantity,
      image: product.images?.[0] || "",
      color: item.color || "",
      capacity: item.capacity || "",
    });
  }

  const isVietqr = payload.paymentMethod === "vietqr";
  const summaryShipping =
    typeof payload.summary?.shipping === "number"
      ? Math.max(0, Math.round(payload.summary.shipping))
      : null;
  const shippingFee =
    summaryShipping !== null
      ? Math.max(SHIPPING_FLAT_FEE, summaryShipping)
      : SHIPPING_FLAT_FEE;
  const grandTotal = itemsTotal + shippingFee;

  const order = await Order.create({
    user: req.user._id,
    items: orderItems,
    shippingInfo: payload.shippingInfo,
    paymentMethod: payload.paymentMethod,
    payment: {
      provider: payload.paymentMethod,
      status: isVietqr ? "awaiting" : "pending",
      message: isVietqr
        ? "Đang chờ bạn thanh toán qua VietQR."
        : "Thanh toán khi nhận hàng.",
    },
    totals: {
      items: itemsTotal,
      shipping: shippingFee,
      grand: grandTotal,
    },
  });

let vietqrMeta = null;

if (isVietqr) {
  try {
    const reference = generateVietqrReference(order._id?.toString?.() || "");
    const transferContent = buildTransferContent(reference);
    const qrImageUrl = buildVietqrImageUrl({
      amount: grandTotal,
      description: transferContent,
    });

    order.payment = {
      provider: "vietqr",
      status: "awaiting",
      reference,
      qrData: qrImageUrl,
      quickLink: qrImageUrl,
      transferContent,
  
    };
    await order.save();

    vietqrMeta = {
      qrImageUrl,
      transferContent,
    };
  } catch (error) {
    await restockOrderInventory(order);
    await Order.findByIdAndDelete(order._id);
    throw error;
  }
} else {
  await adjustUserLifetimeSpend(req.user._id, grandTotal);
}

const hydrated = await populateOrder(Order.findById(order._id));
const responseOrder = buildOrderPayload(hydrated);

if (isVietqr && vietqrMeta) {
  responseOrder.payment = responseOrder.payment || {};
  responseOrder.payment.qrData = vietqrMeta.qrImageUrl;
  responseOrder.payment.quickLink = vietqrMeta.qrImageUrl;
  responseOrder.payment.transferContent = vietqrMeta.transferContent;
}

res.status(201).json({
    success: true,
    message: "Order placed successfully",
    data: responseOrder,
  });
});

export const getMyOrders = asyncHandler(async (req, res) => {
  const orders = await populateOrder(
    Order.find({ user: req.user._id }).sort({ createdAt: -1 })
  );

  let reviewedSet = null;
  const orderIds = orders
    .map((order) =>
      order?._id && typeof order._id.toString === "function"
        ? order._id
        : null
    )
    .filter(Boolean);

  if (orderIds.length) {
    const reviewedDocs = await Review.find({
      user: req.user._id,
      order: { $in: orderIds },
    })
      .select("order product")
      .lean();
    reviewedSet = new Set(
      reviewedDocs
        .map((doc) =>
          buildReviewKey(
            doc.order && typeof doc.order.toString === "function"
              ? doc.order.toString()
              : doc.order?.toString?.(),
            doc.product && typeof doc.product.toString === "function"
              ? doc.product.toString()
              : doc.product?.toString?.()
          )
        )
        .filter((value) => typeof value === "string" && value.length > 0)
    );
  }

  res.json({
    success: true,
    data: orders.map((order) => buildOrderPayload(order, reviewedSet)),
  });
});

export const getMyWarrantyItems = asyncHandler(async (req, res) => {
  const orders = await populateOrder(
    Order.find({
      user: req.user._id,
      status: { $ne: "cancelled" },
    }).sort({ createdAt: -1 })
  );

  const now = dayjs();

  const warrantyItems = [];

  orders.forEach((order) => {
    const baseOrder =
      typeof order.toObject === "function"
        ? order.toObject({ virtuals: true })
        : { ...order };
    const activatedAt = baseOrder.createdAt
      ? new Date(baseOrder.createdAt)
      : new Date();
    const orderId = order._id?.toString?.() || "";
    const orderCode = orderId.slice(-8).toUpperCase();
    const orderStatus = baseOrder.status || "pending";

    const items = Array.isArray(order.items) ? order.items : [];
    items.forEach((item) => {
      const currentItem =
        typeof item.toObject === "function" ? item.toObject() : item;
      const productDoc = currentItem.product;

      const productId = getItemProductId(currentItem);
      const productName =
        productDoc?.name || currentItem.name || "Sản phẩm không xác định";
      const productBrand = productDoc?.brand || "";
      const productSlug = productDoc?.slug || null;
      const warrantyPolicy =
        productDoc?.warrantyPolicy?.trim?.() || FALLBACK_WARRANTY_POLICY;
      const warrantyMonths = resolveWarrantyMonths(productDoc);
      const expiresAt = dayjs(activatedAt).add(warrantyMonths, "month");
      const primaryImage =
        (Array.isArray(productDoc?.images) && productDoc.images[0]) ||
        currentItem.image ||
        "";

      warrantyItems.push({
        orderId,
        orderCode,
        orderStatus,
        productId,
        productSlug,
        productName,
        productBrand,
        quantity: currentItem.quantity || 1,
        price:
          Number(currentItem.price ?? NaN) ||
          Number(productDoc?.finalPrice ?? NaN) ||
          Number(productDoc?.price ?? 0),
        color: currentItem.color || "",
        capacity: currentItem.capacity || "",
        warrantyPolicy,
        warrantyMonths,
        activatedAt: activatedAt.toISOString(),
        expiresAt: expiresAt.toISOString(),
        status: expiresAt.isBefore(now) ? "expired" : "active",
        image: primaryImage,
      });
    });
  });

  res.json({
    success: true,
    data: {
      total: warrantyItems.length,
      active: warrantyItems.filter((item) => item.status === "active").length,
      expired: warrantyItems.filter((item) => item.status === "expired").length,
      items: warrantyItems,
    },
  });
});

export const confirmMyVietqrPayment = asyncHandler(async (req, res) => {
  const order = await Order.findOne({
    _id: req.params.id,
    user: req.user._id,
  });

  if (!order) {
    return res.status(404).json({
      success: false,
      message: "Order not found",
    });
  }

  if (order.paymentMethod !== "vietqr") {
    return res.status(400).json({
      success: false,
      message: "Đơn hàng không sử dụng VietQR",
    });
  }

  const currentStatus = order.payment?.status || "pending";
  if (currentStatus === "completed") {
    const hydrated = await populateOrder(Order.findById(order._id));

    return res.json({
      success: true,
      message: "Thanh toán đã được xác nhận",
      data: buildOrderPayload(hydrated),
    });
  }

  order.payment = order.payment || {};
  order.payment.status = "completed";
  order.payment.confirmedAt = new Date();
  order.payment.provider = "vietqr";
  order.payment.message = "";

  await order.save();

  await adjustUserLifetimeSpend(order.user, order.totals?.grand ?? 0);

  const updated = await populateOrder(Order.findById(order._id));

  res.json({
    success: true,
    message: "Đã xác nhận thanh toán VietQR",
    data: buildOrderPayload(updated),
  });
});

export const getAllOrders = asyncHandler(async (req, res) => {
  const orders = await populateOrder(
    Order.find().sort({ createdAt: -1 })
  );

  res.json({
    success: true,
    data: orders.map((order) => buildOrderPayload(order)),
  });
});

export const updateOrderStatus = asyncHandler(async (req, res) => {
  const { status } = updateStatusSchema.parse(req.body);

  const order = await Order.findById(req.params.id);
  if (!order) {
    return res.status(404).json({
      success: false,
      message: "Order not found",
    });
  }

  const previousStatus = order.status;

  if (order.status === status) {
    const hydrated = await populateOrder(Order.findById(order._id));

    return res.json({
      success: true,
      message: "Order status unchanged",
      data: buildOrderPayload(hydrated),
    });
  }

  if (["cancelled", "delivered"].includes(order.status)) {
    return res.status(400).json({
      success: false,
      message: "Không thể chỉnh sửa đơn hàng hoàn tất",
    });
  }

  order.status = status;
  await order.save();

  if (status === "cancelled" && previousStatus !== "cancelled") {
    await restockOrderInventory(order);
    await adjustUserLifetimeSpend(order.user, -order.totals.grand);
  }

  const updated = await populateOrder(Order.findById(order._id));

  res.json({
    success: true,
    message: "Cập nhật trạng thái đơn hàng",
    data: buildOrderPayload(updated),
  });
});

export const cancelMyOrder = asyncHandler(async (req, res) => {
  const order = await Order.findOne({
    _id: req.params.id,
    user: req.user._id,
  });

  if (!order) {
    return res.status(404).json({
      success: false,
      message: "Order not found",
    });
  }

  if (order.status !== "pending") {
    return res.status(400).json({
      success: false,
      message: "Đơn hàng đã được duyệt và không thể hủy",
    });
  }

  order.status = "cancelled";
  await order.save();

  await restockOrderInventory(order);
  await adjustUserLifetimeSpend(order.user, -order.totals.grand);

  const updated = await populateOrder(Order.findById(order._id));

  res.json({
    success: true,
    message: "Đơn hàng đơn được hủy",
    data: buildOrderPayload(updated),
  });
});
